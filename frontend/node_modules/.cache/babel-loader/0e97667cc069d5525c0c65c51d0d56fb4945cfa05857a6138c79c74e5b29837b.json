{"ast":null,"code":"// src/index.ts\nimport Select from \"react-select\";\n\n// src/components/useComponents.ts\nimport { useMemo as useMemo2 } from \"react\";\nimport { components as defaultComponents } from \"react-select\";\n\n// src/components/wrapMenuList.tsx\nimport composeRefs from \"@seznam/compose-react-refs\";\nimport { useCallback, useEffect, useMemo, useRef } from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nvar CHECK_TIMEOUT = 300;\nfunction wrapMenuList(MenuList2) {\n  function WrappedMenuList(props) {\n    const {\n      selectProps,\n      innerRef\n    } = props;\n    const {\n      handleScrolledToBottom,\n      shouldLoadMore\n    } = selectProps;\n    const checkTimeoutRef = useRef(null);\n    const menuListRef = useRef(null);\n    const shouldHandle = useCallback(() => {\n      const el = menuListRef.current;\n      if (!el) {\n        return false;\n      }\n      const {\n        scrollTop,\n        scrollHeight,\n        clientHeight\n      } = el;\n      return shouldLoadMore(scrollHeight, clientHeight, scrollTop);\n    }, [shouldLoadMore]);\n    const checkAndHandle = useCallback(() => {\n      if (shouldHandle()) {\n        if (handleScrolledToBottom) {\n          handleScrolledToBottom();\n        }\n      }\n    }, [shouldHandle, handleScrolledToBottom]);\n    const setCheckAndHandleTimeout = useMemo(() => {\n      const res = () => {\n        checkAndHandle();\n        checkTimeoutRef.current = setTimeout(res, CHECK_TIMEOUT);\n      };\n      return res;\n    }, [checkAndHandle]);\n    useEffect(() => {\n      setCheckAndHandleTimeout();\n      return () => {\n        if (checkTimeoutRef.current) {\n          clearTimeout(checkTimeoutRef.current);\n        }\n      };\n    }, []);\n    return /* @__PURE__ */jsx(MenuList2, {\n      ...props,\n      innerRef: composeRefs(innerRef, menuListRef)\n    });\n  }\n  return WrappedMenuList;\n}\n\n// src/components/useComponents.ts\nvar MenuList = wrapMenuList(\n// biome-ignore lint/suspicious/noExplicitAny: fix types\ndefaultComponents.MenuList);\nvar useComponents = components => useMemo2(() => ({\n  MenuList,\n  ...components\n}), [components]);\n\n// src/useAsyncPaginate.ts\nimport { useCallback as useCallback3, useState as useState2 } from \"react\";\n\n// src/useAsyncPaginateBase.ts\nimport { useLazyRef } from \"@vtaits/use-lazy-ref\";\nimport { useCallback as useCallback2, useEffect as useEffect2, useMemo as useMemo3, useRef as useRef2, useState } from \"react\";\nimport useIsMountedRef from \"use-is-mounted-ref\";\nimport useLatest from \"use-latest\";\n\n// src/defaultReduceOptions.ts\nvar defaultReduceOptions = (prevOptions, loadedOptions) => [...prevOptions, ...loadedOptions];\n\n// src/defaultShouldLoadMore.ts\nvar AVAILABLE_DELTA = 10;\nvar defaultShouldLoadMore = (scrollHeight, clientHeight, scrollTop) => {\n  const bottomBorder = scrollHeight - clientHeight - AVAILABLE_DELTA;\n  return bottomBorder < scrollTop;\n};\n\n// src/getInitialCache.ts\nvar getInitialCache = params => ({\n  isFirstLoad: true,\n  options: [],\n  hasMore: true,\n  isLoading: false,\n  lockedUntil: 0,\n  additional: params.additional\n});\n\n// src/getInitialOptionsCache.ts\nvar getInitialOptionsCache = ({\n  options,\n  defaultOptions,\n  additional,\n  defaultAdditional\n}) => {\n  const initialOptions = defaultOptions === true ? null : Array.isArray(defaultOptions) ? defaultOptions : options;\n  if (initialOptions) {\n    return {\n      \"\": {\n        isFirstLoad: false,\n        isLoading: false,\n        options: initialOptions,\n        hasMore: true,\n        lockedUntil: 0,\n        additional: defaultAdditional || additional\n      }\n    };\n  }\n  return {};\n};\n\n// src/requestOptions.ts\nimport { getResult } from \"krustykrab\";\nimport sleep from \"sleep-promise\";\n\n// src/validateResponse.ts\nvar errorText = '[react-select-async-paginate] response of \"loadOptions\" should be an object with \"options\" prop, which contains array of options.';\nvar checkIsResponse = response => {\n  if (!response) {\n    return false;\n  }\n  const {\n    options,\n    hasMore\n  } = response;\n  if (!Array.isArray(options)) {\n    return false;\n  }\n  if (typeof hasMore !== \"boolean\" && typeof hasMore !== \"undefined\") {\n    return false;\n  }\n  return true;\n};\nvar validateResponse = response => {\n  if (!checkIsResponse(response)) {\n    console.error(errorText, \"Received:\", response);\n    throw new Error(errorText);\n  }\n  return true;\n};\n\n// src/requestOptions.ts\nvar requestOptions = async (caller, paramsRef, optionsCacheRef, debounceTimeout, setOptionsCache, reduceOptions, isMountedRef, clearCacheOnSearchChange) => {\n  const currentInputValue = paramsRef.current.inputValue;\n  const isCacheEmpty = !optionsCacheRef.current[currentInputValue];\n  const currentOptions = isCacheEmpty ? getInitialCache(paramsRef.current) : optionsCacheRef.current[currentInputValue];\n  if (currentOptions.isLoading || !currentOptions.hasMore || currentOptions.lockedUntil > Date.now()) {\n    return;\n  }\n  setOptionsCache(prevOptionsCache => {\n    if (clearCacheOnSearchChange && caller === \"input-change\") {\n      return {\n        [currentInputValue]: {\n          ...currentOptions,\n          isLoading: true\n        }\n      };\n    }\n    return {\n      ...prevOptionsCache,\n      [currentInputValue]: {\n        ...currentOptions,\n        isLoading: true\n      }\n    };\n  });\n  if (debounceTimeout > 0 && caller === \"input-change\") {\n    await sleep(debounceTimeout);\n    const newInputValue = paramsRef.current.inputValue;\n    if (currentInputValue !== newInputValue) {\n      setOptionsCache(prevOptionsCache => {\n        if (isCacheEmpty) {\n          const {\n            [currentInputValue]: itemForDelete,\n            ...restCache\n          } = prevOptionsCache;\n          return restCache;\n        }\n        return {\n          ...prevOptionsCache,\n          [currentInputValue]: {\n            ...currentOptions,\n            isLoading: false\n          }\n        };\n      });\n      return;\n    }\n  }\n  const {\n    loadOptions,\n    reloadOnErrorTimeout = 0\n  } = paramsRef.current;\n  const result = await getResult(Promise.resolve().then(() => loadOptions(currentInputValue, currentOptions.options, currentOptions.additional)));\n  if (!isMountedRef.current) {\n    return;\n  }\n  if (result.isErr()) {\n    setOptionsCache(prevOptionsCache => ({\n      ...prevOptionsCache,\n      [currentInputValue]: {\n        ...currentOptions,\n        isLoading: false,\n        lockedUntil: Date.now() + reloadOnErrorTimeout\n      }\n    }));\n    return;\n  }\n  const response = result.unwrap();\n  if (validateResponse(response)) {\n    const {\n      options,\n      hasMore\n    } = response;\n    const newAdditional = Object.hasOwn(response, \"additional\") ? response.additional : currentOptions.additional;\n    setOptionsCache(prevOptionsCache => ({\n      ...prevOptionsCache,\n      [currentInputValue]: {\n        ...currentOptions,\n        options: reduceOptions(currentOptions.options, options, newAdditional),\n        hasMore: !!hasMore,\n        isLoading: false,\n        isFirstLoad: false,\n        additional: newAdditional\n      }\n    }));\n  }\n};\n\n// src/useAsyncPaginateBase.ts\nvar increaseStateId = prevStateId => prevStateId + 1;\nvar useAsyncPaginateBase = (params, deps = []) => {\n  const {\n    clearCacheOnSearchChange = false,\n    clearCacheOnMenuClose = false,\n    defaultOptions,\n    loadOptionsOnMenuOpen = true,\n    debounceTimeout = 0,\n    inputValue,\n    menuIsOpen,\n    filterOption = null,\n    reduceOptions = defaultReduceOptions,\n    shouldLoadMore = defaultShouldLoadMore,\n    mapOptionsForMenu = void 0\n  } = params;\n  const menuIsOpenRef = useLatest(menuIsOpen);\n  const isMountedRef = useIsMountedRef();\n  const reduceOptionsRef = useLatest(reduceOptions);\n  const loadOptionsOnMenuOpenRef = useLatest(loadOptionsOnMenuOpen);\n  const isInitRef = useRef2(true);\n  const paramsRef = useRef2(params);\n  paramsRef.current = params;\n  const [_stateId, setStateId] = useState(0);\n  const optionsCacheRef = useLazyRef(() => getInitialOptionsCache(params));\n  const callRequestOptionsRef = useLatest(caller => {\n    requestOptions(caller, paramsRef, optionsCacheRef, debounceTimeout, reduceState => {\n      optionsCacheRef.current = reduceState(optionsCacheRef.current);\n      if (isMountedRef.current) {\n        setStateId(increaseStateId);\n      }\n    }, reduceOptionsRef.current, isMountedRef, clearCacheOnSearchChange);\n  });\n  const handleScrolledToBottom = useCallback2(() => {\n    const currentInputValue = paramsRef.current.inputValue;\n    const currentOptions2 = optionsCacheRef.current[currentInputValue];\n    if (currentOptions2) {\n      callRequestOptionsRef.current(\"menu-scroll\");\n    }\n  }, [callRequestOptionsRef, optionsCacheRef]);\n  useEffect2(() => {\n    if (isInitRef.current) {\n      isInitRef.current = false;\n    } else {\n      optionsCacheRef.current = {};\n      setStateId(increaseStateId);\n    }\n    if (defaultOptions === true) {\n      callRequestOptionsRef.current(\"autoload\");\n    }\n  }, deps);\n  useEffect2(() => {\n    if (menuIsOpenRef.current && !optionsCacheRef.current[inputValue]) {\n      callRequestOptionsRef.current(\"input-change\");\n    }\n  }, [callRequestOptionsRef, inputValue, menuIsOpenRef, optionsCacheRef]);\n  useEffect2(() => {\n    if (menuIsOpen) {\n      if (!optionsCacheRef.current[\"\"] && loadOptionsOnMenuOpenRef.current) {\n        callRequestOptionsRef.current(\"menu-toggle\");\n        return;\n      }\n      return;\n    }\n    if (clearCacheOnMenuClose) {\n      optionsCacheRef.current = {};\n      setStateId(increaseStateId);\n    }\n  }, [callRequestOptionsRef, loadOptionsOnMenuOpenRef, menuIsOpen, optionsCacheRef, clearCacheOnMenuClose]);\n  const currentOptions = optionsCacheRef.current[inputValue] || getInitialCache(params);\n  const options = useMemo3(() => {\n    if (!mapOptionsForMenu) {\n      return currentOptions.options;\n    }\n    return mapOptionsForMenu(currentOptions.options);\n  }, [currentOptions.options, mapOptionsForMenu]);\n  return {\n    handleScrolledToBottom,\n    shouldLoadMore,\n    filterOption,\n    isLoading: currentOptions.isLoading || currentOptions.lockedUntil > Date.now(),\n    isFirstLoad: currentOptions.isFirstLoad,\n    options\n  };\n};\n\n// src/useAsyncPaginate.ts\nvar useAsyncPaginate = (params, deps = []) => {\n  const {\n    inputValue: inputValueParam,\n    menuIsOpen: menuIsOpenParam,\n    defaultInputValue: defaultInputValueParam,\n    defaultMenuIsOpen: defaultMenuIsOpenParam,\n    onInputChange: onInputChangeParam,\n    onMenuClose: onMenuCloseParam,\n    onMenuOpen: onMenuOpenParam\n  } = params;\n  const [inputValueState, setInputValue] = useState2(defaultInputValueParam || \"\");\n  const [menuIsOpenState, setMenuIsOpen] = useState2(!!defaultMenuIsOpenParam);\n  const inputValue = typeof inputValueParam === \"string\" ? inputValueParam : inputValueState;\n  const menuIsOpen = typeof menuIsOpenParam === \"boolean\" ? menuIsOpenParam : menuIsOpenState;\n  const onInputChange = useCallback3((nextInputValue, actionMeta) => {\n    if (onInputChangeParam) {\n      onInputChangeParam(nextInputValue, actionMeta);\n    }\n    setInputValue(nextInputValue);\n  }, [onInputChangeParam]);\n  const onMenuClose = useCallback3(() => {\n    if (onMenuCloseParam) {\n      onMenuCloseParam();\n    }\n    setMenuIsOpen(false);\n  }, [onMenuCloseParam]);\n  const onMenuOpen = useCallback3(() => {\n    if (onMenuOpenParam) {\n      onMenuOpenParam();\n    }\n    setMenuIsOpen(true);\n  }, [onMenuOpenParam]);\n  const baseResult = useAsyncPaginateBase({\n    ...params,\n    inputValue,\n    menuIsOpen\n  }, deps);\n  return {\n    ...baseResult,\n    inputValue,\n    menuIsOpen,\n    onInputChange,\n    onMenuClose,\n    onMenuOpen\n  };\n};\n\n// src/withAsyncPaginate.tsx\nimport { jsx as jsx2 } from \"react/jsx-runtime\";\nvar defaultCacheUniqs = [];\nvar defaultComponents2 = {};\nfunction withAsyncPaginate(SelectComponent) {\n  function WithAsyncPaginate(props) {\n    const {\n      components = defaultComponents2,\n      selectRef = void 0,\n      isLoading: isLoadingProp,\n      cacheUniqs = defaultCacheUniqs,\n      menuPlacement,\n      menuShouldScrollIntoView,\n      ...rest\n    } = props;\n    const asyncPaginateProps = useAsyncPaginate(rest, cacheUniqs);\n    const processedComponents = useComponents(components);\n    const isLoading = typeof isLoadingProp === \"boolean\" ? isLoadingProp : asyncPaginateProps.isLoading;\n    return /* @__PURE__ */jsx2(SelectComponent, {\n      ...props,\n      ...asyncPaginateProps,\n      menuPlacement,\n      menuShouldScrollIntoView: menuPlacement === \"auto\" ? isLoading ? false : menuShouldScrollIntoView : menuShouldScrollIntoView,\n      isLoading,\n      components: processedComponents,\n      ref: selectRef\n    });\n  }\n  return WithAsyncPaginate;\n}\n\n// src/reduceGroupedOptions.ts\nvar checkGroup = group => {\n  if (!group) {\n    return false;\n  }\n  const {\n    label,\n    options\n  } = group;\n  if (typeof label !== \"string\" && typeof label !== \"undefined\") {\n    return false;\n  }\n  if (!Array.isArray(options)) {\n    return false;\n  }\n  return true;\n};\nvar reduceGroupedOptions = (prevOptions, loadedOptions) => {\n  const res = prevOptions.slice();\n  const mapLabelToIndex = {};\n  let prevOptionsIndex = 0;\n  const prevOptionsLength = prevOptions.length;\n  for (const optionOrGroup of loadedOptions) {\n    const group = checkGroup(optionOrGroup) ? optionOrGroup : {\n      options: [optionOrGroup]\n    };\n    const {\n      label = \"\"\n    } = group;\n    let groupIndex = mapLabelToIndex[label];\n    if (typeof groupIndex !== \"number\") {\n      for (; prevOptionsIndex < prevOptionsLength && typeof mapLabelToIndex[label] !== \"number\"; ++prevOptionsIndex) {\n        const prevGroup = prevOptions[prevOptionsIndex];\n        if (checkGroup(prevGroup)) {\n          mapLabelToIndex[prevGroup.label || \"\"] = prevOptionsIndex;\n        }\n      }\n      groupIndex = mapLabelToIndex[label];\n    }\n    if (typeof groupIndex !== \"number\") {\n      mapLabelToIndex[label] = res.length;\n      res.push(group);\n    } else {\n      res[groupIndex] = {\n        ...res[groupIndex],\n        options: [...res[groupIndex].options, ...group.options]\n      };\n    }\n  }\n  return res;\n};\n\n// src/index.ts\nvar AsyncPaginate = withAsyncPaginate(Select);\nexport { AsyncPaginate, checkIsResponse, reduceGroupedOptions, useAsyncPaginate, useAsyncPaginateBase, useComponents, validateResponse, withAsyncPaginate, wrapMenuList };","map":{"version":3,"names":["Select","useMemo","useMemo2","components","defaultComponents","composeRefs","useCallback","useEffect","useRef","jsx","CHECK_TIMEOUT","wrapMenuList","MenuList2","WrappedMenuList","props","selectProps","innerRef","handleScrolledToBottom","shouldLoadMore","checkTimeoutRef","menuListRef","shouldHandle","el","current","scrollTop","scrollHeight","clientHeight","checkAndHandle","setCheckAndHandleTimeout","res","setTimeout","clearTimeout","MenuList","useComponents","useCallback3","useState","useState2","useLazyRef","useCallback2","useEffect2","useMemo3","useRef2","useIsMountedRef","useLatest","defaultReduceOptions","prevOptions","loadedOptions","AVAILABLE_DELTA","defaultShouldLoadMore","bottomBorder","getInitialCache","params","isFirstLoad","options","hasMore","isLoading","lockedUntil","additional","getInitialOptionsCache","defaultOptions","defaultAdditional","initialOptions","Array","isArray","getResult","sleep","errorText","checkIsResponse","response","validateResponse","console","error","Error","requestOptions","caller","paramsRef","optionsCacheRef","debounceTimeout","setOptionsCache","reduceOptions","isMountedRef","clearCacheOnSearchChange","currentInputValue","inputValue","isCacheEmpty","currentOptions","Date","now","prevOptionsCache","newInputValue","itemForDelete","restCache","loadOptions","reloadOnErrorTimeout","result","Promise","resolve","then","isErr","unwrap","newAdditional","Object","hasOwn","increaseStateId","prevStateId","useAsyncPaginateBase","deps","clearCacheOnMenuClose","loadOptionsOnMenuOpen","menuIsOpen","filterOption","mapOptionsForMenu","menuIsOpenRef","reduceOptionsRef","loadOptionsOnMenuOpenRef","isInitRef","_stateId","setStateId","callRequestOptionsRef","reduceState","currentOptions2","useAsyncPaginate","inputValueParam","menuIsOpenParam","defaultInputValue","defaultInputValueParam","defaultMenuIsOpen","defaultMenuIsOpenParam","onInputChange","onInputChangeParam","onMenuClose","onMenuCloseParam","onMenuOpen","onMenuOpenParam","inputValueState","setInputValue","menuIsOpenState","setMenuIsOpen","nextInputValue","actionMeta","baseResult","jsx2","defaultCacheUniqs","defaultComponents2","withAsyncPaginate","SelectComponent","WithAsyncPaginate","selectRef","isLoadingProp","cacheUniqs","menuPlacement","menuShouldScrollIntoView","rest","asyncPaginateProps","processedComponents","ref","checkGroup","group","label","reduceGroupedOptions","slice","mapLabelToIndex","prevOptionsIndex","prevOptionsLength","length","optionOrGroup","groupIndex","prevGroup","push","AsyncPaginate"],"sources":["/home/vboxuser/apps-dev/myweather-app3/frontend/node_modules/react-select-async-paginate/src/index.ts","/home/vboxuser/apps-dev/myweather-app3/frontend/node_modules/react-select-async-paginate/src/components/useComponents.ts","/home/vboxuser/apps-dev/myweather-app3/frontend/node_modules/react-select-async-paginate/src/components/wrapMenuList.tsx","/home/vboxuser/apps-dev/myweather-app3/frontend/node_modules/react-select-async-paginate/src/useAsyncPaginate.ts","/home/vboxuser/apps-dev/myweather-app3/frontend/node_modules/react-select-async-paginate/src/useAsyncPaginateBase.ts","/home/vboxuser/apps-dev/myweather-app3/frontend/node_modules/react-select-async-paginate/src/defaultReduceOptions.ts","/home/vboxuser/apps-dev/myweather-app3/frontend/node_modules/react-select-async-paginate/src/defaultShouldLoadMore.ts","/home/vboxuser/apps-dev/myweather-app3/frontend/node_modules/react-select-async-paginate/src/getInitialCache.ts","/home/vboxuser/apps-dev/myweather-app3/frontend/node_modules/react-select-async-paginate/src/getInitialOptionsCache.ts","/home/vboxuser/apps-dev/myweather-app3/frontend/node_modules/react-select-async-paginate/src/requestOptions.ts","/home/vboxuser/apps-dev/myweather-app3/frontend/node_modules/react-select-async-paginate/src/validateResponse.ts","/home/vboxuser/apps-dev/myweather-app3/frontend/node_modules/react-select-async-paginate/src/withAsyncPaginate.tsx","/home/vboxuser/apps-dev/myweather-app3/frontend/node_modules/react-select-async-paginate/src/reduceGroupedOptions.ts"],"sourcesContent":["import Select from \"react-select\";\nimport { withAsyncPaginate } from \"./withAsyncPaginate\";\n\nexport { wrapMenuList } from \"./components/wrapMenuList\";\nexport { reduceGroupedOptions } from \"./reduceGroupedOptions\";\n\nexport { withAsyncPaginate };\n\nexport {\n\tcheckIsResponse,\n\tvalidateResponse,\n} from \"./validateResponse\";\nexport { useAsyncPaginateBase } from \"./useAsyncPaginateBase\";\nexport { useAsyncPaginate } from \"./useAsyncPaginate\";\nexport { useComponents } from \"./components/useComponents\";\n\nexport const AsyncPaginate = withAsyncPaginate(Select);\n\nexport * from \"./types\";\n","import { type ComponentType, useMemo } from \"react\";\nimport type {\n\tGroupBase,\n\tMenuListProps,\n\tSelectComponentsConfig,\n} from \"react-select\";\nimport { components as defaultComponents } from \"react-select\";\nimport { wrapMenuList } from \"./wrapMenuList\";\n\nexport const MenuList = wrapMenuList(\n\t// biome-ignore lint/suspicious/noExplicitAny: fix types\n\tdefaultComponents.MenuList as ComponentType<MenuListProps<any, any, any>>,\n);\n\nexport const useComponents = <\n\tOptionType,\n\tGroup extends GroupBase<OptionType>,\n\tIsMulti extends boolean,\n>(\n\tcomponents: SelectComponentsConfig<OptionType, IsMulti, Group>,\n): SelectComponentsConfig<OptionType, IsMulti, Group> =>\n\tuseMemo(\n\t\t() => ({\n\t\t\tMenuList: MenuList as unknown as SelectComponentsConfig<\n\t\t\t\tOptionType,\n\t\t\t\tIsMulti,\n\t\t\t\tGroup\n\t\t\t>[\"MenuList\"],\n\t\t\t...components,\n\t\t}),\n\t\t[components],\n\t);\n","import composeRefs from \"@seznam/compose-react-refs\";\nimport { useCallback, useEffect, useMemo, useRef } from \"react\";\nimport type { ComponentType, ReactElement } from \"react\";\nimport type { GroupBase, MenuListProps } from \"react-select\";\nimport type { ShouldLoadMore } from \"../types\";\n\nexport const CHECK_TIMEOUT = 300;\n\nexport type BaseSelectProps = {\n\thandleScrolledToBottom?: () => void;\n\tshouldLoadMore: ShouldLoadMore;\n};\n\ntype MenuListType<\n\tOption = unknown,\n\tIsMulti extends boolean = boolean,\n\tGroup extends GroupBase<Option> = GroupBase<Option>,\n> = ComponentType<MenuListProps<Option, IsMulti, Group>>;\n\nexport function wrapMenuList<\n\tOption = unknown,\n\tIsMulti extends boolean = boolean,\n\tGroup extends GroupBase<Option> = GroupBase<Option>,\n>(MenuList: MenuListType<Option, IsMulti, Group>) {\n\tfunction WrappedMenuList(\n\t\tprops: MenuListProps<Option, IsMulti, Group>,\n\t): ReactElement {\n\t\tconst { selectProps, innerRef } = props;\n\n\t\tconst { handleScrolledToBottom, shouldLoadMore } =\n\t\t\tselectProps as unknown as BaseSelectProps;\n\n\t\tconst checkTimeoutRef = useRef<number | null>(null);\n\t\tconst menuListRef = useRef<HTMLDivElement>(null);\n\n\t\tconst shouldHandle = useCallback(() => {\n\t\t\tconst el = menuListRef.current;\n\n\t\t\t// menu is not rendered\n\t\t\tif (!el) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tconst { scrollTop, scrollHeight, clientHeight } = el;\n\n\t\t\treturn shouldLoadMore(scrollHeight, clientHeight, scrollTop);\n\t\t}, [shouldLoadMore]);\n\n\t\tconst checkAndHandle = useCallback(() => {\n\t\t\tif (shouldHandle()) {\n\t\t\t\tif (handleScrolledToBottom) {\n\t\t\t\t\thandleScrolledToBottom();\n\t\t\t\t}\n\t\t\t}\n\t\t}, [shouldHandle, handleScrolledToBottom]);\n\n\t\tconst setCheckAndHandleTimeout = useMemo(() => {\n\t\t\tconst res = () => {\n\t\t\t\tcheckAndHandle();\n\n\t\t\t\tcheckTimeoutRef.current = setTimeout(\n\t\t\t\t\tres,\n\t\t\t\t\tCHECK_TIMEOUT,\n\t\t\t\t) as unknown as number;\n\t\t\t};\n\n\t\t\treturn res;\n\t\t}, [checkAndHandle]);\n\n\t\t// biome-ignore lint/correctness/useExhaustiveDependencies: call only on init\n\t\tuseEffect(() => {\n\t\t\tsetCheckAndHandleTimeout();\n\n\t\t\treturn () => {\n\t\t\t\tif (checkTimeoutRef.current) {\n\t\t\t\t\tclearTimeout(checkTimeoutRef.current);\n\t\t\t\t}\n\t\t\t};\n\t\t}, []);\n\n\t\treturn (\n\t\t\t<MenuList\n\t\t\t\t{...props}\n\t\t\t\tinnerRef={composeRefs<HTMLDivElement>(innerRef, menuListRef)}\n\t\t\t/>\n\t\t);\n\t}\n\n\treturn WrappedMenuList;\n}\n","import { useCallback, useState } from \"react\";\nimport type { GroupBase, InputActionMeta } from \"react-select\";\nimport type {\n\tUseAsyncPaginateBaseResult,\n\tUseAsyncPaginateParams,\n\tUseAsyncPaginateResult,\n} from \"./types\";\nimport { useAsyncPaginateBase } from \"./useAsyncPaginateBase\";\n\nexport const useAsyncPaginate = <\n\tOptionType,\n\tGroup extends GroupBase<OptionType>,\n\tAdditional,\n>(\n\tparams: UseAsyncPaginateParams<OptionType, Group, Additional>,\n\tdeps: ReadonlyArray<unknown> = [],\n): UseAsyncPaginateResult<OptionType, Group> => {\n\tconst {\n\t\tinputValue: inputValueParam,\n\t\tmenuIsOpen: menuIsOpenParam,\n\t\tdefaultInputValue: defaultInputValueParam,\n\t\tdefaultMenuIsOpen: defaultMenuIsOpenParam,\n\t\tonInputChange: onInputChangeParam,\n\t\tonMenuClose: onMenuCloseParam,\n\t\tonMenuOpen: onMenuOpenParam,\n\t} = params;\n\n\tconst [inputValueState, setInputValue] = useState(\n\t\tdefaultInputValueParam || \"\",\n\t);\n\tconst [menuIsOpenState, setMenuIsOpen] = useState(!!defaultMenuIsOpenParam);\n\n\tconst inputValue: string =\n\t\ttypeof inputValueParam === \"string\" ? inputValueParam : inputValueState;\n\n\tconst menuIsOpen: boolean =\n\t\ttypeof menuIsOpenParam === \"boolean\" ? menuIsOpenParam : menuIsOpenState;\n\n\tconst onInputChange = useCallback(\n\t\t(nextInputValue: string, actionMeta: InputActionMeta): void => {\n\t\t\tif (onInputChangeParam) {\n\t\t\t\tonInputChangeParam(nextInputValue, actionMeta);\n\t\t\t}\n\n\t\t\tsetInputValue(nextInputValue);\n\t\t},\n\t\t[onInputChangeParam],\n\t);\n\n\tconst onMenuClose = useCallback((): void => {\n\t\tif (onMenuCloseParam) {\n\t\t\tonMenuCloseParam();\n\t\t}\n\n\t\tsetMenuIsOpen(false);\n\t}, [onMenuCloseParam]);\n\n\tconst onMenuOpen = useCallback((): void => {\n\t\tif (onMenuOpenParam) {\n\t\t\tonMenuOpenParam();\n\t\t}\n\n\t\tsetMenuIsOpen(true);\n\t}, [onMenuOpenParam]);\n\n\tconst baseResult: UseAsyncPaginateBaseResult<OptionType, Group> =\n\t\tuseAsyncPaginateBase(\n\t\t\t{\n\t\t\t\t...params,\n\t\t\t\tinputValue,\n\t\t\t\tmenuIsOpen,\n\t\t\t},\n\t\t\tdeps,\n\t\t);\n\n\treturn {\n\t\t...baseResult,\n\t\tinputValue,\n\t\tmenuIsOpen,\n\t\tonInputChange,\n\t\tonMenuClose,\n\t\tonMenuOpen,\n\t};\n};\n","import { useLazyRef } from \"@vtaits/use-lazy-ref\";\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport type { GroupBase } from \"react-select\";\nimport useIsMountedRef from \"use-is-mounted-ref\";\nimport useLatest from \"use-latest\";\nimport { defaultReduceOptions } from \"./defaultReduceOptions\";\nimport { defaultShouldLoadMore } from \"./defaultShouldLoadMore\";\nimport { getInitialCache } from \"./getInitialCache\";\nimport { getInitialOptionsCache } from \"./getInitialOptionsCache\";\nimport { requestOptions } from \"./requestOptions\";\nimport type {\n\tOptionsCacheItem,\n\tRequestOptionsCallerType,\n\tUseAsyncPaginateBaseParams,\n\tUseAsyncPaginateBaseResult,\n} from \"./types\";\n\nexport const increaseStateId = (prevStateId: number): number => prevStateId + 1;\n\nexport const useAsyncPaginateBase = <\n\tOptionType,\n\tGroup extends GroupBase<OptionType>,\n\tAdditional,\n>(\n\tparams: UseAsyncPaginateBaseParams<OptionType, Group, Additional>,\n\tdeps: ReadonlyArray<unknown> = [],\n): UseAsyncPaginateBaseResult<OptionType, Group> => {\n\tconst {\n\t\tclearCacheOnSearchChange = false,\n\t\tclearCacheOnMenuClose = false,\n\t\tdefaultOptions,\n\t\tloadOptionsOnMenuOpen = true,\n\t\tdebounceTimeout = 0,\n\t\tinputValue,\n\t\tmenuIsOpen,\n\t\tfilterOption = null,\n\t\treduceOptions = defaultReduceOptions,\n\t\tshouldLoadMore = defaultShouldLoadMore,\n\t\tmapOptionsForMenu = undefined,\n\t} = params;\n\n\tconst menuIsOpenRef = useLatest(menuIsOpen);\n\tconst isMountedRef = useIsMountedRef();\n\tconst reduceOptionsRef = useLatest(reduceOptions);\n\tconst loadOptionsOnMenuOpenRef = useLatest(loadOptionsOnMenuOpen);\n\n\tconst isInitRef = useRef<boolean>(true);\n\tconst paramsRef =\n\t\tuseRef<UseAsyncPaginateBaseParams<OptionType, Group, Additional>>(params);\n\n\tparamsRef.current = params;\n\n\tconst [_stateId, setStateId] = useState(0);\n\n\tconst optionsCacheRef = useLazyRef(() => getInitialOptionsCache(params));\n\n\tconst callRequestOptionsRef = useLatest(\n\t\t(caller: RequestOptionsCallerType) => {\n\t\t\trequestOptions(\n\t\t\t\tcaller,\n\t\t\t\tparamsRef,\n\t\t\t\toptionsCacheRef,\n\t\t\t\tdebounceTimeout,\n\t\t\t\t(reduceState) => {\n\t\t\t\t\toptionsCacheRef.current = reduceState(optionsCacheRef.current);\n\n\t\t\t\t\tif (isMountedRef.current) {\n\t\t\t\t\t\tsetStateId(increaseStateId);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\treduceOptionsRef.current,\n\t\t\t\tisMountedRef,\n\t\t\t\tclearCacheOnSearchChange,\n\t\t\t);\n\t\t},\n\t);\n\n\tconst handleScrolledToBottom = useCallback(() => {\n\t\tconst currentInputValue = paramsRef.current.inputValue;\n\t\tconst currentOptions = optionsCacheRef.current[currentInputValue];\n\n\t\tif (currentOptions) {\n\t\t\tcallRequestOptionsRef.current(\"menu-scroll\");\n\t\t}\n\t}, [callRequestOptionsRef, optionsCacheRef]);\n\n\t// biome-ignore lint/correctness/useExhaustiveDependencies: `callRequestOptionsRef` is a ref\n\tuseEffect(() => {\n\t\tif (isInitRef.current) {\n\t\t\tisInitRef.current = false;\n\t\t} else {\n\t\t\toptionsCacheRef.current = {};\n\t\t\tsetStateId(increaseStateId);\n\t\t}\n\n\t\tif (defaultOptions === true) {\n\t\t\tcallRequestOptionsRef.current(\"autoload\");\n\t\t}\n\t}, deps);\n\n\tuseEffect(() => {\n\t\tif (menuIsOpenRef.current && !optionsCacheRef.current[inputValue]) {\n\t\t\tcallRequestOptionsRef.current(\"input-change\");\n\t\t}\n\t}, [callRequestOptionsRef, inputValue, menuIsOpenRef, optionsCacheRef]);\n\n\tuseEffect(() => {\n\t\tif (menuIsOpen) {\n\t\t\tif (!optionsCacheRef.current[\"\"] && loadOptionsOnMenuOpenRef.current) {\n\t\t\t\tcallRequestOptionsRef.current(\"menu-toggle\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (clearCacheOnMenuClose) {\n\t\t\toptionsCacheRef.current = {};\n\n\t\t\tsetStateId(increaseStateId);\n\t\t}\n\t}, [\n\t\tcallRequestOptionsRef,\n\t\tloadOptionsOnMenuOpenRef,\n\t\tmenuIsOpen,\n\t\toptionsCacheRef,\n\t\tclearCacheOnMenuClose,\n\t]);\n\n\tconst currentOptions: OptionsCacheItem<OptionType, Group, Additional> =\n\t\toptionsCacheRef.current[inputValue] || getInitialCache(params);\n\n\tconst options = useMemo(() => {\n\t\tif (!mapOptionsForMenu) {\n\t\t\treturn currentOptions.options;\n\t\t}\n\n\t\treturn mapOptionsForMenu(currentOptions.options);\n\t}, [currentOptions.options, mapOptionsForMenu]);\n\n\treturn {\n\t\thandleScrolledToBottom,\n\t\tshouldLoadMore,\n\t\tfilterOption,\n\t\tisLoading:\n\t\t\tcurrentOptions.isLoading || currentOptions.lockedUntil > Date.now(),\n\t\tisFirstLoad: currentOptions.isFirstLoad,\n\t\toptions,\n\t};\n};\n","import type { GroupBase, OptionsOrGroups } from \"react-select\";\n\nexport const defaultReduceOptions = <\n\tOptionType,\n\tGroup extends GroupBase<OptionType>,\n>(\n\tprevOptions: OptionsOrGroups<OptionType, Group>,\n\tloadedOptions: OptionsOrGroups<OptionType, Group>,\n) => [...prevOptions, ...loadedOptions];\n","import type { ShouldLoadMore } from \"./types\";\n\nconst AVAILABLE_DELTA = 10;\n\nexport const defaultShouldLoadMore: ShouldLoadMore = (\n\tscrollHeight,\n\tclientHeight,\n\tscrollTop,\n) => {\n\tconst bottomBorder = scrollHeight - clientHeight - AVAILABLE_DELTA;\n\n\treturn bottomBorder < scrollTop;\n};\n","import type { GroupBase } from \"react-select\";\nimport type { OptionsCacheItem, UseAsyncPaginateBaseParams } from \"./types\";\n\nexport const getInitialCache = <\n\tOptionType,\n\tGroup extends GroupBase<OptionType>,\n\tAdditional,\n>(\n\tparams: UseAsyncPaginateBaseParams<OptionType, Group, Additional>,\n): OptionsCacheItem<OptionType, Group, Additional> => ({\n\tisFirstLoad: true,\n\toptions: [],\n\thasMore: true,\n\tisLoading: false,\n\tlockedUntil: 0,\n\tadditional: params.additional,\n});\n","import type { GroupBase } from \"react-select\";\nimport type { OptionsCache, UseAsyncPaginateBaseParams } from \"./types\";\n\nexport const getInitialOptionsCache = <\n\tOptionType,\n\tGroup extends GroupBase<OptionType>,\n\tAdditional,\n>({\n\toptions,\n\tdefaultOptions,\n\tadditional,\n\tdefaultAdditional,\n}: UseAsyncPaginateBaseParams<OptionType, Group, Additional>): OptionsCache<\n\tOptionType,\n\tGroup,\n\tAdditional\n> => {\n\tconst initialOptions =\n\t\tdefaultOptions === true\n\t\t\t? null\n\t\t\t: Array.isArray(defaultOptions)\n\t\t\t\t? defaultOptions\n\t\t\t\t: options;\n\n\tif (initialOptions) {\n\t\treturn {\n\t\t\t\"\": {\n\t\t\t\tisFirstLoad: false,\n\t\t\t\tisLoading: false,\n\t\t\t\toptions: initialOptions,\n\t\t\t\thasMore: true,\n\t\t\t\tlockedUntil: 0,\n\t\t\t\tadditional: defaultAdditional || additional,\n\t\t\t},\n\t\t};\n\t}\n\n\treturn {};\n};\n","import { getResult } from \"krustykrab\";\nimport type { RefObject } from \"react\";\nimport type { GroupBase } from \"react-select\";\nimport sleep from \"sleep-promise\";\nimport { getInitialCache } from \"./getInitialCache\";\nimport type {\n\tOptionsCache,\n\tOptionsCacheItem,\n\tReduceOptions,\n\tRequestOptionsCallerType,\n\tUseAsyncPaginateBaseParams,\n} from \"./types\";\nimport { validateResponse } from \"./validateResponse\";\n\ntype MapOptionsCache<\n\tOptionType,\n\tGroup extends GroupBase<OptionType>,\n\tAdditional,\n> = (\n\tprevCache: OptionsCache<OptionType, Group, Additional>,\n) => OptionsCache<OptionType, Group, Additional>;\n\ntype SetOptionsCache<\n\tOptionType,\n\tGroup extends GroupBase<OptionType>,\n\tAdditional,\n> = (stateMapper: MapOptionsCache<OptionType, Group, Additional>) => void;\n\nexport const requestOptions = async <\n\tOptionType,\n\tGroup extends GroupBase<OptionType>,\n\tAdditional,\n>(\n\tcaller: RequestOptionsCallerType,\n\tparamsRef: RefObject<\n\t\tUseAsyncPaginateBaseParams<OptionType, Group, Additional>\n\t>,\n\toptionsCacheRef: RefObject<OptionsCache<OptionType, Group, Additional>>,\n\tdebounceTimeout: number,\n\tsetOptionsCache: SetOptionsCache<OptionType, Group, Additional>,\n\treduceOptions: ReduceOptions<OptionType, Group, Additional>,\n\tisMountedRef: {\n\t\tcurrent: boolean;\n\t},\n\tclearCacheOnSearchChange: boolean,\n): Promise<void> => {\n\tconst currentInputValue = paramsRef.current.inputValue;\n\n\tconst isCacheEmpty = !optionsCacheRef.current[currentInputValue];\n\n\tconst currentOptions: OptionsCacheItem<OptionType, Group, Additional> =\n\t\tisCacheEmpty\n\t\t\t? getInitialCache(paramsRef.current)\n\t\t\t: optionsCacheRef.current[currentInputValue];\n\n\tif (\n\t\tcurrentOptions.isLoading ||\n\t\t!currentOptions.hasMore ||\n\t\tcurrentOptions.lockedUntil > Date.now()\n\t) {\n\t\treturn;\n\t}\n\n\tsetOptionsCache(\n\t\t(\n\t\t\tprevOptionsCache: OptionsCache<OptionType, Group, Additional>,\n\t\t): OptionsCache<OptionType, Group, Additional> => {\n\t\t\tif (clearCacheOnSearchChange && caller === \"input-change\") {\n\t\t\t\treturn {\n\t\t\t\t\t[currentInputValue]: {\n\t\t\t\t\t\t...currentOptions,\n\t\t\t\t\t\tisLoading: true,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t...prevOptionsCache,\n\t\t\t\t[currentInputValue]: {\n\t\t\t\t\t...currentOptions,\n\t\t\t\t\tisLoading: true,\n\t\t\t\t},\n\t\t\t};\n\t\t},\n\t);\n\n\tif (debounceTimeout > 0 && caller === \"input-change\") {\n\t\tawait sleep(debounceTimeout);\n\n\t\tconst newInputValue = paramsRef.current.inputValue;\n\n\t\tif (currentInputValue !== newInputValue) {\n\t\t\tsetOptionsCache((prevOptionsCache) => {\n\t\t\t\tif (isCacheEmpty) {\n\t\t\t\t\tconst { [currentInputValue]: itemForDelete, ...restCache } =\n\t\t\t\t\t\tprevOptionsCache;\n\n\t\t\t\t\treturn restCache;\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\t...prevOptionsCache,\n\t\t\t\t\t[currentInputValue]: {\n\t\t\t\t\t\t...currentOptions,\n\t\t\t\t\t\tisLoading: false,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tconst { loadOptions, reloadOnErrorTimeout = 0 } = paramsRef.current;\n\n\tconst result = await getResult(\n\t\tPromise.resolve().then(() =>\n\t\t\tloadOptions(\n\t\t\t\tcurrentInputValue,\n\t\t\t\tcurrentOptions.options,\n\t\t\t\tcurrentOptions.additional,\n\t\t\t),\n\t\t),\n\t);\n\n\tif (!isMountedRef.current) {\n\t\treturn;\n\t}\n\n\tif (result.isErr()) {\n\t\tsetOptionsCache((prevOptionsCache) => ({\n\t\t\t...prevOptionsCache,\n\t\t\t[currentInputValue]: {\n\t\t\t\t...currentOptions,\n\t\t\t\tisLoading: false,\n\t\t\t\tlockedUntil: Date.now() + reloadOnErrorTimeout,\n\t\t\t},\n\t\t}));\n\n\t\treturn;\n\t}\n\n\tconst response = result.unwrap();\n\n\tif (validateResponse(response)) {\n\t\tconst { options, hasMore } = response;\n\n\t\tconst newAdditional = Object.hasOwn(response, \"additional\")\n\t\t\t? response.additional\n\t\t\t: currentOptions.additional;\n\n\t\tsetOptionsCache((prevOptionsCache) => ({\n\t\t\t...prevOptionsCache,\n\t\t\t[currentInputValue]: {\n\t\t\t\t...currentOptions,\n\t\t\t\toptions: reduceOptions(currentOptions.options, options, newAdditional),\n\t\t\t\thasMore: !!hasMore,\n\t\t\t\tisLoading: false,\n\t\t\t\tisFirstLoad: false,\n\t\t\t\tadditional: newAdditional,\n\t\t\t},\n\t\t}));\n\t}\n};\n","import type { GroupBase } from \"react-select\";\nimport type { Response } from \"./types\";\n\nexport const errorText =\n\t'[react-select-async-paginate] response of \"loadOptions\" should be an object with \"options\" prop, which contains array of options.';\n\nexport const checkIsResponse = <\n\tOptionType,\n\tGroup extends GroupBase<OptionType>,\n\tAdditional,\n>(\n\tresponse: unknown,\n): response is Response<OptionType, Group, Additional> => {\n\tif (!response) {\n\t\treturn false;\n\t}\n\n\tconst { options, hasMore } = response as {\n\t\toptions?: unknown;\n\t\thasMore?: unknown;\n\t};\n\n\tif (!Array.isArray(options)) {\n\t\treturn false;\n\t}\n\n\tif (typeof hasMore !== \"boolean\" && typeof hasMore !== \"undefined\") {\n\t\treturn false;\n\t}\n\n\treturn true;\n};\n\nexport const validateResponse = <\n\tOptionType,\n\tGroup extends GroupBase<OptionType>,\n\tAdditional,\n>(\n\tresponse: unknown,\n): response is Response<OptionType, Group, Additional> => {\n\tif (!checkIsResponse(response)) {\n\t\tconsole.error(errorText, \"Received:\", response);\n\t\tthrow new Error(errorText);\n\t}\n\n\treturn true;\n};\n","import type { ReactElement, Ref } from \"react\";\nimport type {\n\tGroupBase,\n\tSelectInstance,\n\tProps as SelectProps,\n} from \"react-select\";\nimport { useComponents } from \"./components/useComponents\";\nimport type {\n\tAsyncPaginateProps,\n\tUseAsyncPaginateResult,\n\tWithAsyncPaginateType,\n} from \"./types\";\nimport { useAsyncPaginate } from \"./useAsyncPaginate\";\n\nconst defaultCacheUniqs: unknown[] = [];\nconst defaultComponents = {};\n\ntype SelectComponentType = <\n\tOption = unknown,\n\tIsMulti extends boolean = boolean,\n\tGroup extends GroupBase<Option> = GroupBase<Option>,\n>(\n\tprops: SelectProps<Option, IsMulti, Group> & {\n\t\tref?: Ref<SelectInstance<Option, IsMulti, Group>>;\n\t},\n) => ReactElement;\n\nexport function withAsyncPaginate(\n\tSelectComponent: SelectComponentType,\n): WithAsyncPaginateType {\n\tfunction WithAsyncPaginate<\n\t\tOptionType,\n\t\tGroup extends GroupBase<OptionType>,\n\t\tAdditional,\n\t\tIsMulti extends boolean = false,\n\t>(\n\t\tprops: AsyncPaginateProps<OptionType, Group, Additional, IsMulti>,\n\t): ReactElement {\n\t\tconst {\n\t\t\tcomponents = defaultComponents,\n\t\t\tselectRef = undefined,\n\t\t\tisLoading: isLoadingProp,\n\t\t\tcacheUniqs = defaultCacheUniqs,\n\t\t\tmenuPlacement,\n\t\t\tmenuShouldScrollIntoView,\n\t\t\t...rest\n\t\t} = props;\n\n\t\tconst asyncPaginateProps: UseAsyncPaginateResult<OptionType, Group> =\n\t\t\tuseAsyncPaginate(rest, cacheUniqs);\n\n\t\tconst processedComponents = useComponents<OptionType, Group, IsMulti>(\n\t\t\tcomponents,\n\t\t);\n\n\t\tconst isLoading =\n\t\t\ttypeof isLoadingProp === \"boolean\"\n\t\t\t\t? isLoadingProp\n\t\t\t\t: asyncPaginateProps.isLoading;\n\n\t\treturn (\n\t\t\t<SelectComponent\n\t\t\t\t{...props}\n\t\t\t\t{...asyncPaginateProps}\n\t\t\t\tmenuPlacement={menuPlacement}\n\t\t\t\t// Recount menu position on load options\n\t\t\t\tmenuShouldScrollIntoView={\n\t\t\t\t\tmenuPlacement === \"auto\"\n\t\t\t\t\t\t? isLoading\n\t\t\t\t\t\t\t? false\n\t\t\t\t\t\t\t: menuShouldScrollIntoView\n\t\t\t\t\t\t: menuShouldScrollIntoView\n\t\t\t\t}\n\t\t\t\tisLoading={isLoading}\n\t\t\t\tcomponents={processedComponents}\n\t\t\t\tref={selectRef}\n\t\t\t/>\n\t\t);\n\t}\n\n\treturn WithAsyncPaginate;\n}\n","import type { GroupBase, OptionsOrGroups } from \"react-select\";\n\nexport const checkGroup = (group: unknown): group is GroupBase<unknown> => {\n\tif (!group) {\n\t\treturn false;\n\t}\n\n\tconst { label, options } = group as {\n\t\tlabel?: unknown;\n\t\toptions?: unknown;\n\t};\n\n\tif (typeof label !== \"string\" && typeof label !== \"undefined\") {\n\t\treturn false;\n\t}\n\n\tif (!Array.isArray(options)) {\n\t\treturn false;\n\t}\n\n\treturn true;\n};\n\nexport const reduceGroupedOptions = <\n\tOptionType,\n\tGroup extends GroupBase<OptionType>,\n>(\n\tprevOptions: OptionsOrGroups<OptionType, Group>,\n\tloadedOptions: OptionsOrGroups<OptionType, Group>,\n): OptionsOrGroups<OptionType, Group> => {\n\tconst res = prevOptions.slice();\n\n\tconst mapLabelToIndex: Record<string, number> = {};\n\tlet prevOptionsIndex = 0;\n\tconst prevOptionsLength = prevOptions.length;\n\n\tfor (const optionOrGroup of loadedOptions) {\n\t\tconst group = checkGroup(optionOrGroup)\n\t\t\t? optionOrGroup\n\t\t\t: ({\n\t\t\t\t\toptions: [optionOrGroup],\n\t\t\t\t} as unknown as Group);\n\n\t\tconst { label = \"\" } = group;\n\n\t\tlet groupIndex = mapLabelToIndex[label];\n\t\tif (typeof groupIndex !== \"number\") {\n\t\t\tfor (\n\t\t\t\t;\n\t\t\t\tprevOptionsIndex < prevOptionsLength &&\n\t\t\t\ttypeof mapLabelToIndex[label] !== \"number\";\n\t\t\t\t++prevOptionsIndex\n\t\t\t) {\n\t\t\t\tconst prevGroup = prevOptions[prevOptionsIndex];\n\n\t\t\t\tif (checkGroup(prevGroup)) {\n\t\t\t\t\tmapLabelToIndex[prevGroup.label || \"\"] = prevOptionsIndex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgroupIndex = mapLabelToIndex[label];\n\t\t}\n\n\t\tif (typeof groupIndex !== \"number\") {\n\t\t\tmapLabelToIndex[label] = res.length;\n\t\t\tres.push(group);\n\t\t} else {\n\t\t\tres[groupIndex] = {\n\t\t\t\t...res[groupIndex],\n\t\t\t\toptions: [...(res[groupIndex] as Group).options, ...group.options],\n\t\t\t};\n\t\t}\n\t}\n\n\treturn res;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}