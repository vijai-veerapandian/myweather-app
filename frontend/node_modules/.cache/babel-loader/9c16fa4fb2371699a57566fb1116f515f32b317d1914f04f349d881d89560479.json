{"ast":null,"code":"var _jsxFileName = \"/home/vboxuser/apps-dev/myweather-app3/frontend/src/components/search/search.js\",\n  _s = $RefreshSig$();\nimport React, { useState } from \"react\";\nimport { AsyncPaginate } from \"react-select-async-paginate\";\n// Removed unused imports for this specific component's logic\n// import { REACT_APP_GEO_API_URL, geoApiOptions } from \"../../api.js\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Search = ({\n  onSearchChange\n}) => {\n  _s();\n  const [search, setSearch] = useState(null);\n\n  // Using async/await for better readability and error handling\n  const loadOptions = async inputValue => {\n    // No need to fetch if input is empty\n    if (!inputValue || inputValue.trim() === '') {\n      return {\n        options: []\n      };\n    }\n    try {\n      // --- CORRECTED FETCH CALL ---\n      // Use the relative path that Nginx will proxy to the backend's /cities endpoint\n      const response = await fetch(`/api/cities?minPopulation=1000000&namePrefix=${inputValue}`\n      // No need to pass geoApiOptions here, as the backend handles authentication\n      // with the actual GeoDB API. Send headers ONLY if your backend endpoint\n      // specifically requires them (e.g., Content-Type, custom auth).\n      );\n\n      // Check if the response from *your backend* was successful\n      if (!response.ok) {\n        console.error(\"Backend API Error Status:\", response.status);\n        // Try to get more specific error info from backend response body\n        const errorText = await response.text();\n        console.error(\"Backend API Error Response:\", errorText);\n        // Return empty options to prevent react-select-async-paginate error\n        return {\n          options: []\n        };\n      }\n\n      // Parse the JSON response from *your backend*\n      const responseData = await response.json();\n\n      // --- Validate the structure returned by YOUR backend ---\n      // Assuming your backend correctly forwards the GeoDB structure { data: [...] }\n      if (!responseData || !Array.isArray(responseData.data)) {\n        console.error(\"Unexpected response structure from backend:\", responseData);\n        return {\n          options: []\n        };\n      }\n\n      // Map the data received from *your backend*\n      return {\n        options: responseData.data.map(city => ({\n          value: `${city.latitude} ${city.longitude}`,\n          label: `${city.name}, ${city.countryCode}` // Ensure backend provides these fields\n        }))\n      };\n    } catch (error) {\n      // Catch network errors (e.g., Nginx down, DNS issues) or JSON parsing errors\n      console.error(\"Fetch/Parse Error in loadOptions:\", error);\n      // Return empty options to prevent react-select-async-paginate error\n      return {\n        options: []\n      };\n    }\n  };\n  const handleOnChange = searchData => {\n    setSearch(searchData);\n    onSearchChange(searchData);\n  };\n  return /*#__PURE__*/_jsxDEV(AsyncPaginate, {\n    placeholder: \"Search for city\",\n    debounceTimeout: 600 // Time in ms to wait after user stops typing\n    ,\n    value: search,\n    onChange: handleOnChange,\n    loadOptions: loadOptions // Pass the async function directly\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 68,\n    columnNumber: 9\n  }, this);\n};\n_s(Search, \"rZ+0pF47En10nDqJpRK7x4d9dB0=\");\n_c = Search;\nexport default Search;\nvar _c;\n$RefreshReg$(_c, \"Search\");","map":{"version":3,"names":["React","useState","AsyncPaginate","jsxDEV","_jsxDEV","Search","onSearchChange","_s","search","setSearch","loadOptions","inputValue","trim","options","response","fetch","ok","console","error","status","errorText","text","responseData","json","Array","isArray","data","map","city","value","latitude","longitude","label","name","countryCode","handleOnChange","searchData","placeholder","debounceTimeout","onChange","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/home/vboxuser/apps-dev/myweather-app3/frontend/src/components/search/search.js"],"sourcesContent":["import React, { useState } from \"react\";\nimport { AsyncPaginate } from \"react-select-async-paginate\";\n// Removed unused imports for this specific component's logic\n// import { REACT_APP_GEO_API_URL, geoApiOptions } from \"../../api.js\";\n\nconst Search = ({ onSearchChange }) => {\n    const [search, setSearch] = useState(null);\n\n    // Using async/await for better readability and error handling\n    const loadOptions = async (inputValue) => {\n        // No need to fetch if input is empty\n        if (!inputValue || inputValue.trim() === '') {\n            return { options: [] };\n        }\n\n        try {\n            // --- CORRECTED FETCH CALL ---\n            // Use the relative path that Nginx will proxy to the backend's /cities endpoint\n            const response = await fetch(\n                `/api/cities?minPopulation=1000000&namePrefix=${inputValue}`\n                // No need to pass geoApiOptions here, as the backend handles authentication\n                // with the actual GeoDB API. Send headers ONLY if your backend endpoint\n                // specifically requires them (e.g., Content-Type, custom auth).\n            );\n\n            // Check if the response from *your backend* was successful\n            if (!response.ok) {\n                console.error(\"Backend API Error Status:\", response.status);\n                // Try to get more specific error info from backend response body\n                const errorText = await response.text();\n                console.error(\"Backend API Error Response:\", errorText);\n                // Return empty options to prevent react-select-async-paginate error\n                return { options: [] };\n            }\n\n            // Parse the JSON response from *your backend*\n            const responseData = await response.json();\n\n            // --- Validate the structure returned by YOUR backend ---\n            // Assuming your backend correctly forwards the GeoDB structure { data: [...] }\n            if (!responseData || !Array.isArray(responseData.data)) {\n                 console.error(\"Unexpected response structure from backend:\", responseData);\n                 return { options: [] };\n            }\n\n            // Map the data received from *your backend*\n            return {\n                options: responseData.data.map((city) => ({\n                    value: `${city.latitude} ${city.longitude}`,\n                    label: `${city.name}, ${city.countryCode}`, // Ensure backend provides these fields\n                })),\n            };\n\n        } catch (error) {\n            // Catch network errors (e.g., Nginx down, DNS issues) or JSON parsing errors\n            console.error(\"Fetch/Parse Error in loadOptions:\", error);\n            // Return empty options to prevent react-select-async-paginate error\n            return { options: [] };\n        }\n    };\n\n    const handleOnChange = (searchData) => {\n        setSearch(searchData);\n        onSearchChange(searchData);\n    };\n\n    return (\n        <AsyncPaginate\n            placeholder=\"Search for city\"\n            debounceTimeout={600} // Time in ms to wait after user stops typing\n            value={search}\n            onChange={handleOnChange}\n            loadOptions={loadOptions} // Pass the async function directly\n        />\n    );\n};\n\nexport default Search;"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,QAAQ,QAAQ,OAAO;AACvC,SAASC,aAAa,QAAQ,6BAA6B;AAC3D;AACA;AAAA,SAAAC,MAAA,IAAAC,OAAA;AAEA,MAAMC,MAAM,GAAGA,CAAC;EAAEC;AAAe,CAAC,KAAK;EAAAC,EAAA;EACnC,MAAM,CAACC,MAAM,EAAEC,SAAS,CAAC,GAAGR,QAAQ,CAAC,IAAI,CAAC;;EAE1C;EACA,MAAMS,WAAW,GAAG,MAAOC,UAAU,IAAK;IACtC;IACA,IAAI,CAACA,UAAU,IAAIA,UAAU,CAACC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;MACzC,OAAO;QAAEC,OAAO,EAAE;MAAG,CAAC;IAC1B;IAEA,IAAI;MACA;MACA;MACA,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CACxB,gDAAgDJ,UAAU;MAC1D;MACA;MACA;MACJ,CAAC;;MAED;MACA,IAAI,CAACG,QAAQ,CAACE,EAAE,EAAE;QACdC,OAAO,CAACC,KAAK,CAAC,2BAA2B,EAAEJ,QAAQ,CAACK,MAAM,CAAC;QAC3D;QACA,MAAMC,SAAS,GAAG,MAAMN,QAAQ,CAACO,IAAI,CAAC,CAAC;QACvCJ,OAAO,CAACC,KAAK,CAAC,6BAA6B,EAAEE,SAAS,CAAC;QACvD;QACA,OAAO;UAAEP,OAAO,EAAE;QAAG,CAAC;MAC1B;;MAEA;MACA,MAAMS,YAAY,GAAG,MAAMR,QAAQ,CAACS,IAAI,CAAC,CAAC;;MAE1C;MACA;MACA,IAAI,CAACD,YAAY,IAAI,CAACE,KAAK,CAACC,OAAO,CAACH,YAAY,CAACI,IAAI,CAAC,EAAE;QACnDT,OAAO,CAACC,KAAK,CAAC,6CAA6C,EAAEI,YAAY,CAAC;QAC1E,OAAO;UAAET,OAAO,EAAE;QAAG,CAAC;MAC3B;;MAEA;MACA,OAAO;QACHA,OAAO,EAAES,YAAY,CAACI,IAAI,CAACC,GAAG,CAAEC,IAAI,KAAM;UACtCC,KAAK,EAAE,GAAGD,IAAI,CAACE,QAAQ,IAAIF,IAAI,CAACG,SAAS,EAAE;UAC3CC,KAAK,EAAE,GAAGJ,IAAI,CAACK,IAAI,KAAKL,IAAI,CAACM,WAAW,EAAE,CAAE;QAChD,CAAC,CAAC;MACN,CAAC;IAEL,CAAC,CAAC,OAAOhB,KAAK,EAAE;MACZ;MACAD,OAAO,CAACC,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;MACzD;MACA,OAAO;QAAEL,OAAO,EAAE;MAAG,CAAC;IAC1B;EACJ,CAAC;EAED,MAAMsB,cAAc,GAAIC,UAAU,IAAK;IACnC3B,SAAS,CAAC2B,UAAU,CAAC;IACrB9B,cAAc,CAAC8B,UAAU,CAAC;EAC9B,CAAC;EAED,oBACIhC,OAAA,CAACF,aAAa;IACVmC,WAAW,EAAC,iBAAiB;IAC7BC,eAAe,EAAE,GAAI,CAAC;IAAA;IACtBT,KAAK,EAAErB,MAAO;IACd+B,QAAQ,EAAEJ,cAAe;IACzBzB,WAAW,EAAEA,WAAY,CAAC;EAAA;IAAA8B,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAC7B,CAAC;AAEV,CAAC;AAACpC,EAAA,CAtEIF,MAAM;AAAAuC,EAAA,GAANvC,MAAM;AAwEZ,eAAeA,MAAM;AAAC,IAAAuC,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}