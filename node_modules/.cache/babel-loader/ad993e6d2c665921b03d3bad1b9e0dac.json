{"ast":null,"code":"// src/index.ts\nimport Select from \"react-select\";\n\n// src/useAsyncPaginate.ts\nimport { useCallback as useCallback2, useState as useState2 } from \"react\";\n\n// src/useAsyncPaginateBase.ts\nimport { useLazyRef } from \"@vtaits/use-lazy-ref\";\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport useIsMountedRef from \"use-is-mounted-ref\";\nimport useLatest from \"use-latest\";\n\n// src/defaultReduceOptions.ts\nvar defaultReduceOptions = (prevOptions, loadedOptions) => [...prevOptions, ...loadedOptions];\n\n// src/defaultShouldLoadMore.ts\nvar AVAILABLE_DELTA = 10;\nvar defaultShouldLoadMore = (scrollHeight, clientHeight, scrollTop) => {\n  const bottomBorder = scrollHeight - clientHeight - AVAILABLE_DELTA;\n  return bottomBorder < scrollTop;\n};\n\n// src/getInitialCache.ts\nvar getInitialCache = params => ({\n  isFirstLoad: true,\n  options: [],\n  hasMore: true,\n  isLoading: false,\n  lockedUntil: 0,\n  additional: params.additional\n});\n\n// src/getInitialOptionsCache.ts\nvar getInitialOptionsCache = ({\n  options,\n  defaultOptions,\n  additional,\n  defaultAdditional\n}) => {\n  const initialOptions = defaultOptions === true ? null : Array.isArray(defaultOptions) ? defaultOptions : options;\n  if (initialOptions) {\n    return {\n      \"\": {\n        isFirstLoad: false,\n        isLoading: false,\n        options: initialOptions,\n        hasMore: true,\n        lockedUntil: 0,\n        additional: defaultAdditional || additional\n      }\n    };\n  }\n  return {};\n};\n\n// src/requestOptions.ts\nimport { getResult } from \"krustykrab\";\nimport sleep from \"sleep-promise\";\n\n// src/validateResponse.ts\nvar errorText = '[react-select-async-paginate] response of \"loadOptions\" should be an object with \"options\" prop, which contains array of options.';\nvar checkIsResponse = response => {\n  if (!response) {\n    return false;\n  }\n  const {\n    options,\n    hasMore\n  } = response;\n  if (!Array.isArray(options)) {\n    return false;\n  }\n  if (typeof hasMore !== \"boolean\" && typeof hasMore !== \"undefined\") {\n    return false;\n  }\n  return true;\n};\nvar validateResponse = response => {\n  if (!checkIsResponse(response)) {\n    console.error(errorText, \"Received:\", response);\n    throw new Error(errorText);\n  }\n  return true;\n};\n\n// src/requestOptions.ts\nvar requestOptions = async (caller, paramsRef, optionsCacheRef, debounceTimeout, setOptionsCache, reduceOptions, isMountedRef) => {\n  const currentInputValue = paramsRef.current.inputValue;\n  const isCacheEmpty = !optionsCacheRef.current[currentInputValue];\n  const currentOptions = isCacheEmpty ? getInitialCache(paramsRef.current) : optionsCacheRef.current[currentInputValue];\n  if (currentOptions.isLoading || !currentOptions.hasMore || currentOptions.lockedUntil > Date.now()) {\n    return;\n  }\n  setOptionsCache(prevOptionsCache => ({\n    ...prevOptionsCache,\n    [currentInputValue]: {\n      ...currentOptions,\n      isLoading: true\n    }\n  }));\n  if (debounceTimeout > 0 && caller === \"input-change\") {\n    await sleep(debounceTimeout);\n    const newInputValue = paramsRef.current.inputValue;\n    if (currentInputValue !== newInputValue) {\n      setOptionsCache(prevOptionsCache => {\n        if (isCacheEmpty) {\n          const {\n            [currentInputValue]: itemForDelete,\n            ...restCache\n          } = prevOptionsCache;\n          return restCache;\n        }\n        return {\n          ...prevOptionsCache,\n          [currentInputValue]: {\n            ...currentOptions,\n            isLoading: false\n          }\n        };\n      });\n      return;\n    }\n  }\n  const {\n    loadOptions,\n    reloadOnErrorTimeout = 0\n  } = paramsRef.current;\n  const result = await getResult(Promise.resolve().then(() => loadOptions(currentInputValue, currentOptions.options, currentOptions.additional)));\n  if (!isMountedRef.current) {\n    return;\n  }\n  if (result.isErr()) {\n    setOptionsCache(prevOptionsCache => ({\n      ...prevOptionsCache,\n      [currentInputValue]: {\n        ...currentOptions,\n        isLoading: false,\n        lockedUntil: Date.now() + reloadOnErrorTimeout\n      }\n    }));\n    return;\n  }\n  const response = result.unwrap();\n  if (validateResponse(response)) {\n    const {\n      options,\n      hasMore\n    } = response;\n    const newAdditional = Object.hasOwn(response, \"additional\") ? response.additional : currentOptions.additional;\n    setOptionsCache(prevOptionsCache => ({\n      ...prevOptionsCache,\n      [currentInputValue]: {\n        ...currentOptions,\n        options: reduceOptions(currentOptions.options, options, newAdditional),\n        hasMore: !!hasMore,\n        isLoading: false,\n        isFirstLoad: false,\n        additional: newAdditional\n      }\n    }));\n  }\n};\n\n// src/useAsyncPaginateBase.ts\nvar increaseStateId = prevStateId => prevStateId + 1;\nvar useAsyncPaginateBase = (params, deps = []) => {\n  const {\n    defaultOptions,\n    loadOptionsOnMenuOpen = true,\n    debounceTimeout = 0,\n    inputValue,\n    menuIsOpen,\n    filterOption = null,\n    reduceOptions = defaultReduceOptions,\n    shouldLoadMore = defaultShouldLoadMore,\n    mapOptionsForMenu = void 0\n  } = params;\n  const menuIsOpenRef = useLatest(menuIsOpen);\n  const isMountedRef = useIsMountedRef();\n  const reduceOptionsRef = useLatest(reduceOptions);\n  const loadOptionsOnMenuOpenRef = useLatest(loadOptionsOnMenuOpen);\n  const isInitRef = useRef(true);\n  const paramsRef = useRef(params);\n  paramsRef.current = params;\n  const [_stateId, setStateId] = useState(0);\n  const optionsCacheRef = useLazyRef(() => getInitialOptionsCache(params));\n  const callRequestOptionsRef = useLatest(caller => {\n    requestOptions(caller, paramsRef, optionsCacheRef, debounceTimeout, reduceState => {\n      optionsCacheRef.current = reduceState(optionsCacheRef.current);\n      if (isMountedRef.current) {\n        setStateId(increaseStateId);\n      }\n    }, reduceOptionsRef.current, isMountedRef);\n  });\n  const handleScrolledToBottom = useCallback(() => {\n    const currentInputValue = paramsRef.current.inputValue;\n    const currentOptions2 = optionsCacheRef.current[currentInputValue];\n    if (currentOptions2) {\n      callRequestOptionsRef.current(\"menu-scroll\");\n    }\n  }, [callRequestOptionsRef, optionsCacheRef]);\n  useEffect(() => {\n    if (isInitRef.current) {\n      isInitRef.current = false;\n    } else {\n      optionsCacheRef.current = {};\n      setStateId(increaseStateId);\n    }\n    if (defaultOptions === true) {\n      callRequestOptionsRef.current(\"autoload\");\n    }\n  }, deps);\n  useEffect(() => {\n    if (menuIsOpenRef.current && !optionsCacheRef.current[inputValue]) {\n      callRequestOptionsRef.current(\"input-change\");\n    }\n  }, [callRequestOptionsRef, inputValue, menuIsOpenRef, optionsCacheRef]);\n  useEffect(() => {\n    if (menuIsOpen && !optionsCacheRef.current[\"\"] && loadOptionsOnMenuOpenRef.current) {\n      callRequestOptionsRef.current(\"menu-toggle\");\n    }\n  }, [callRequestOptionsRef, loadOptionsOnMenuOpenRef, menuIsOpen, optionsCacheRef]);\n  const currentOptions = optionsCacheRef.current[inputValue] || getInitialCache(params);\n  const options = useMemo(() => {\n    if (!mapOptionsForMenu) {\n      return currentOptions.options;\n    }\n    return mapOptionsForMenu(currentOptions.options);\n  }, [currentOptions.options, mapOptionsForMenu]);\n  return {\n    handleScrolledToBottom,\n    shouldLoadMore,\n    filterOption,\n    isLoading: currentOptions.isLoading || currentOptions.lockedUntil > Date.now(),\n    isFirstLoad: currentOptions.isFirstLoad,\n    options\n  };\n};\n\n// src/useAsyncPaginate.ts\nvar useAsyncPaginate = (params, deps = []) => {\n  const {\n    inputValue: inputValueParam,\n    menuIsOpen: menuIsOpenParam,\n    defaultInputValue: defaultInputValueParam,\n    defaultMenuIsOpen: defaultMenuIsOpenParam,\n    onInputChange: onInputChangeParam,\n    onMenuClose: onMenuCloseParam,\n    onMenuOpen: onMenuOpenParam\n  } = params;\n  const [inputValueState, setInputValue] = useState2(defaultInputValueParam || \"\");\n  const [menuIsOpenState, setMenuIsOpen] = useState2(!!defaultMenuIsOpenParam);\n  const inputValue = typeof inputValueParam === \"string\" ? inputValueParam : inputValueState;\n  const menuIsOpen = typeof menuIsOpenParam === \"boolean\" ? menuIsOpenParam : menuIsOpenState;\n  const onInputChange = useCallback2((nextInputValue, actionMeta) => {\n    if (onInputChangeParam) {\n      onInputChangeParam(nextInputValue, actionMeta);\n    }\n    setInputValue(nextInputValue);\n  }, [onInputChangeParam]);\n  const onMenuClose = useCallback2(() => {\n    if (onMenuCloseParam) {\n      onMenuCloseParam();\n    }\n    setMenuIsOpen(false);\n  }, [onMenuCloseParam]);\n  const onMenuOpen = useCallback2(() => {\n    if (onMenuOpenParam) {\n      onMenuOpenParam();\n    }\n    setMenuIsOpen(true);\n  }, [onMenuOpenParam]);\n  const baseResult = useAsyncPaginateBase({\n    ...params,\n    inputValue,\n    menuIsOpen\n  }, deps);\n  return {\n    ...baseResult,\n    inputValue,\n    menuIsOpen,\n    onInputChange,\n    onMenuClose,\n    onMenuOpen\n  };\n};\n\n// src/useComponents.ts\nimport { useMemo as useMemo3 } from \"react\";\nimport { components as defaultComponents } from \"react-select\";\n\n// src/wrapMenuList.tsx\nimport composeRefs from \"@seznam/compose-react-refs\";\nimport { useCallback as useCallback3, useEffect as useEffect2, useMemo as useMemo2, useRef as useRef2 } from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nvar CHECK_TIMEOUT = 300;\nfunction wrapMenuList(MenuList2) {\n  function WrappedMenuList(props) {\n    const {\n      selectProps,\n      innerRef\n    } = props;\n    const {\n      handleScrolledToBottom,\n      shouldLoadMore\n    } = selectProps;\n    const checkTimeoutRef = useRef2(null);\n    const menuListRef = useRef2(null);\n    const shouldHandle = useCallback3(() => {\n      const el = menuListRef.current;\n      if (!el) {\n        return false;\n      }\n      const {\n        scrollTop,\n        scrollHeight,\n        clientHeight\n      } = el;\n      return shouldLoadMore(scrollHeight, clientHeight, scrollTop);\n    }, [shouldLoadMore]);\n    const checkAndHandle = useCallback3(() => {\n      if (shouldHandle()) {\n        if (handleScrolledToBottom) {\n          handleScrolledToBottom();\n        }\n      }\n    }, [shouldHandle, handleScrolledToBottom]);\n    const setCheckAndHandleTimeout = useMemo2(() => {\n      const res = () => {\n        checkAndHandle();\n        checkTimeoutRef.current = setTimeout(res, CHECK_TIMEOUT);\n      };\n      return res;\n    }, [checkAndHandle]);\n    useEffect2(() => {\n      setCheckAndHandleTimeout();\n      return () => {\n        if (checkTimeoutRef.current) {\n          clearTimeout(checkTimeoutRef.current);\n        }\n      };\n    }, []);\n    return /* @__PURE__ */jsx(MenuList2, {\n      ...props,\n      innerRef: composeRefs(innerRef, menuListRef)\n    });\n  }\n  return WrappedMenuList;\n}\n\n// src/useComponents.ts\nvar MenuList = wrapMenuList(\n// biome-ignore lint/suspicious/noExplicitAny: fix types\ndefaultComponents.MenuList);\nvar useComponents = components => useMemo3(() => ({\n  MenuList,\n  ...components\n}), [components]);\n\n// src/withAsyncPaginate.tsx\nimport { jsx as jsx2 } from \"react/jsx-runtime\";\nvar defaultCacheUniqs = [];\nvar defaultComponents2 = {};\nfunction withAsyncPaginate(SelectComponent) {\n  function WithAsyncPaginate(props) {\n    const {\n      components = defaultComponents2,\n      selectRef = void 0,\n      isLoading: isLoadingProp,\n      cacheUniqs = defaultCacheUniqs,\n      ...rest\n    } = props;\n    const asyncPaginateProps = useAsyncPaginate(rest, cacheUniqs);\n    const processedComponents = useComponents(components);\n    const isLoading = typeof isLoadingProp === \"boolean\" ? isLoadingProp : asyncPaginateProps.isLoading;\n    return /* @__PURE__ */jsx2(SelectComponent, {\n      ...props,\n      ...asyncPaginateProps,\n      isLoading,\n      components: processedComponents,\n      ref: selectRef\n    });\n  }\n  return WithAsyncPaginate;\n}\n\n// src/reduceGroupedOptions.ts\nvar checkGroup = group => {\n  if (!group) {\n    return false;\n  }\n  const {\n    label,\n    options\n  } = group;\n  if (typeof label !== \"string\" && typeof label !== \"undefined\") {\n    return false;\n  }\n  if (!Array.isArray(options)) {\n    return false;\n  }\n  return true;\n};\nvar reduceGroupedOptions = (prevOptions, loadedOptions) => {\n  const res = prevOptions.slice();\n  const mapLabelToIndex = {};\n  let prevOptionsIndex = 0;\n  const prevOptionsLength = prevOptions.length;\n  for (const optionOrGroup of loadedOptions) {\n    const group = checkGroup(optionOrGroup) ? optionOrGroup : {\n      options: [optionOrGroup]\n    };\n    const {\n      label = \"\"\n    } = group;\n    let groupIndex = mapLabelToIndex[label];\n    if (typeof groupIndex !== \"number\") {\n      for (; prevOptionsIndex < prevOptionsLength && typeof mapLabelToIndex[label] !== \"number\"; ++prevOptionsIndex) {\n        const prevGroup = prevOptions[prevOptionsIndex];\n        if (checkGroup(prevGroup)) {\n          mapLabelToIndex[prevGroup.label || \"\"] = prevOptionsIndex;\n        }\n      }\n      groupIndex = mapLabelToIndex[label];\n    }\n    if (typeof groupIndex !== \"number\") {\n      mapLabelToIndex[label] = res.length;\n      res.push(group);\n    } else {\n      res[groupIndex] = {\n        ...res[groupIndex],\n        options: [...res[groupIndex].options, ...group.options]\n      };\n    }\n  }\n  return res;\n};\n\n// src/index.ts\nvar AsyncPaginate = withAsyncPaginate(Select);\nexport { AsyncPaginate, checkIsResponse, reduceGroupedOptions, useAsyncPaginate, useAsyncPaginateBase, useComponents, validateResponse, withAsyncPaginate, wrapMenuList };","map":null,"metadata":{},"sourceType":"module"}